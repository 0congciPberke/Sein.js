# CPU性能优化

根据经验一般来讲，CPU端的开销主要开销来源于**矩阵计算**、**物理引擎**、**Program编译**等，当然也不排除一些复杂的**逻辑计算**。所以想要优化CPU开销，就必须从这几点着手：

## Actor结构

Actor由多个Component构成，尤其是SceneActor，其下面可能会挂载多个要渲染的模型，这时候一般有两种方案：  

1. 使用多个SceneActor级联。
2. 一个SceneActor挂载多个SceneComponent。

我想即使是从直觉上考虑，大家也知道第一种方式的开销可能远高于第二种。最主要的是在更新逻辑中，`PrimitiveComponent`是不会进入更新队列的，所以一个`SceneActor`挂载多个`PrimitiveComponent`的话，其更新逻辑的开销基本可以忽略，但若反过来就大不相同了。  

所以我们尽量选择第二种结构，来达到最佳的性能（特殊场景除外）。这种优化一般在Unity中，通过`Sein Scene Node`组件来中的`Children Type`来完成。

## Actor属性

除了上面提到的Actor的结构，Actor本身也有很多属性可以帮助我们进行在特定情况下的性能优化。比如`persistent`属性可以在关卡切换时继承改Actor，可以减少创建开销；再比如`emitComponentsDestroy`、`updateOnEverTick`这种属性可以精确控制Actor下所有Component的是否执行更新和销毁逻辑；再比如`isStatic`则用于完全不会改变的静态物体，一般是一些建筑、地形，可以免去不必要的渲染时矩阵计算开销。  

同样，这些属性也可以在Unity中通过`Sein Scene Node`组件中的同名变量进行设定。

## 渲染更新

前面提到了，CPU开销中的大头一般是渲染本身和骨骼动画计算两种。渲染本身的开销主要分为两种——GL资源的初始化和后续模型矩阵的更新计算，而骨骼动画就是大量矩阵计算。  

对于模型矩阵更新的优化，其实上面已经说过了，就是对那些完全不需要更新的建筑等场景布置的物体，可以直接用`actor.isStatic`或者`component.isStatic`来关掉其每帧的矩阵更新。  

对于GL资源的初始化优化，一般分为两个部分——缓存复用和防止Program切换。缓存复用下一节会说，防止Program切换则是尽量避免在运行时进行Shader的重编译，一些操作比如**添加删除灯光**、**修改UV通道**、**动态修改光照贴图**等都会有这种开销，而灯光的修改这种又是全局性的，会影响到几乎所有Shader，所以建议在场景初始化的时候就决定好这些渲染参数，尽量避免动态修改。

而对于骨骼动画而言，就只有减少单模型的骨骼数量、减少具有骨骼动画的模型的数量了，这个必须从美术资源下手，没有特别好的方案。

## 事件触发

在事件系统方面，我们也可以做出一些优化，这个优化在默认的`game.hid`事件就可以体现，其下面挂载的所有用户输入事件都是经过了**节流**的，即所有的事件都会在每一帧更新时才会真正发出，在这期间无论你触发多少次，都之后在帧更新前广播一次。这种设计可以减少很多不必要的逻辑开销，同时也使得输入更加可控。  

想要使用这种特性有两种方式，可以直接在触发事件时指定第三个参数`immediately`为`false`：  

```ts
event.trigger('test', null, false);
```

如此一来事件便会延迟到帧更新前触发。  

另一种方式则是自定义触发器，定义派生自`EventTrigger`的类并指定其中的`autoFlush`为`false`即可，`HID`中的事件即如此定义。

## 物理系统

如果你的项目使用了物理引擎，那么根据不同的情况，也有很多优化方法。  

物理引擎在Actor层次的体现就是两种组件——刚体组件`RigidBodyComponent`和各种碰撞体组件。刚体组件本身有许多可配置的属性，其中有三个特别用于特定场合的优化：  

1. unControl：设置为`false`可节省大量计算，但失去了从渲染世界到物理世界同步的能力，用于仅仅完全受到物理引擎影响或者完全静态的物体。
2. physicStatic：设置为`false`同样可节省大量计算，但失去了从物理世界到渲染世界同步的能力，用于仅仅完全受到游戏逻辑影响或者完全静态的物体。
3. Sleeping：设为`true`即可免去几乎所有计算，但此时物体将完全不受物理引擎影响，用于不需要物理计算，而是仅仅使用碰撞体来进行拾取操作的场合。

## 实例复用

很多情况下我们需要用到类似于**对象池**这样的优化手段，即一开始创建多个物体，但并不直接使用它们，而是将它们存入一个池子中，需要的时候在拿出来用。这么做的好处是非常明显的——创建一个对象的开销是不可忽视的，而游戏作为软实时系统，宁愿在一开始多分配一些内存，来换取运行时的速度。当然这个也不是绝对的，要按照实际的项目来规划。  

我们知道Sein中创建SceneActor必须走`world.addActor`方法，其必然会导致actor实际显示于场景中，当然开发者也可以直接将其`visible`设为`false`来隐藏，但这仅仅是将其从渲染队列中剔除，它下面的更新逻辑和挂载的组件还在正常运作，这可能无法达到预期的效果。所以这就需要我们有一个既要**让actor停止运作**又不能**真的将其销毁**的方法，并且还能让actor在停止后还能高效恢复运作。  

Sein提供了`unLink`、`reLink`方法以及配对的`onUnLink`和`onReLink`生命周期来解决这个问题。`unLink`
和`reLink`都是Actor层次的操作，而两个生命周期则是Actor和Component都会触发的，通过它们我们可以轻松完成类似于对象池的功能，具体方法可见实例[UnLink和ReLink](../../example/core/unlink-relink)。
