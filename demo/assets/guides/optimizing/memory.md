# 传输体积和内存优化

如果分析出来是内存问题，那么同时往往也会有传输体积的问题。

## 模型大小优化

对于3D应用，资源体积的量往往比一般应用要大很多，其中首当其冲的就是3D模型，这就需要我们有一些特别手段去优化模型大小，包括其传输大小以及在内存中的大小。

Sein提供的工具链可以帮我们做到这一点，利用[seinjs-gltf-loader](../../extension/toolchains/seinjs-gltf-loader)中的`compress`选项，加上`gzip`压缩，针对模型本身你至少可以获得**4倍~10倍**的传输体积收益。

而对于模型在内存中的占用，我们也提供了优化方案：  

1. 在做模型的时候若没优化好，可以再Unity中利用其丰富的生态提供的工具进行低模生成，比如这个工具：[UnityMeshSimplify](https://github.com/ecidevilin/UnityMeshSimplify)。
2. 如果能够保证资源提交到GPU后就不再使用，可以在加载资源的时候传入参数`forceCreateNewBuffer`为`true`， 实例化的时候设置`@todo`。

## 削除不必要的数据

在展示型项目中，由于移动端性能受限，所以很多时候我们都是将光影信息Bake到纹理的。在这种状况下，实际上我们是不需要图元数据中的**法线和切线**的，通过剔除这些数据，我们可以削减视状况**1/2 ~ 1/3**的模型体积。在Sein的工具链中，我们非常容易做到这一点，只需要在Unity导出时在勾选导出工具中的**Unlit(No Normals)**选项即可。

## 纹理大小优化

在模型图元数据大小之外，还有一个非常值得关注的内存开销便是纹理了，而在游戏业界，也针对纹理本身有着各种各样的优化方案，其中最为通用的便是**压缩纹理**。

得益于设备的进步，我们统计下来发现不支持压缩纹理的设备（主要在安卓5以下的系统）比例已经极小，所以已经可以广泛铺开了。

Sein提供的[seinjs-gltf-loader](../../extension/toolchains/seinjs-gltf-loader)中的`compressTextures`选项便可以帮助我们无缝得集成压缩纹理功能，开发者基本不会有感知。

Sein目前的压缩纹理方案是完全**预处理**的并支持**智能降级**，所以可以同时**大幅节省图片解码时间**、**压缩5~8倍内存占用**。但相对的，发布时的资源打包时间、以及最终的资源大小就会高一些。这个看具体取舍。

不过如果不便使用压缩纹理，也可以直接用Unity输出`RGBA4444`的纹理，当然，这里还是建议通过**seinjs-gltf-loader**来实现压缩纹理/RGBA4444/RGB565的配置引入。

同时和图元数据一样，我们也可以将提交GPU后不再需要使用的纹理在CPU端释放掉：创建纹理的时候使用`isImageCanRelease`参数或者后续设置即可。如果是在Unity中导出的，基本都会自动处理。

>但也要注意，如果在CPU端释放了资源，那么GL上下文丢失后将无法再恢复。

### GL资源复用

GL资源的主要来源是模型图元数据和Shader需要的各种纹理、以及Shader本身。GL资源本身有限，而Shader编译也需要开销，所以如何使用最少的数据来完成项目是很重要的指标。  

Sein的渲染引擎Hilo本身自带缓存机制，可以缓存Shader编译后的Program，所以一般这个不会出现什么问题，我们最需要考虑的还是顶点数据和纹理的复用。

顶点数据，在Sein中的体现其实就是`PrimitiveComponent`下面的`Geometry`，对于具有相同图元数据的模型，比如一只红色的猪和一只蓝色的猪，就可以使用相同的`geometry`（不要clone）和不同的`material`。如果是使用Unity扩展导出场景，这个优化一般在Unity导出时候就做了，如果是完全自己创建的物体就要住了。

纹理的复用就不多说了，一般引擎这边也会自动处理。

### 释放资源

如果你的项目已经复杂到需要完全精确控制GL资源的生命周期，那么可以使用`sceneComponent.needReleaseGlRes`或者其代理容器的`sceneActor.needReleaseGlRes`来控制资源的释放。

默认情况下，只要是开发者自行创建的Actor，一旦从场景中移除，那么其GL资源将会被一并自动销毁（当然，要所有用到该资源的Actor都被移除）。  

而通过`game.resource.instantiate`，从资源中实例化的Actor，将不会自动销毁，销毁将在开发者手动使用`resource.release`释放资源时完成。
