# GPU性能优化

一般来讲，GPU端的开销主要开销来源于**Shader运算**和**CPU提交数据到GPU**，所以我们也可以从这两点来优化：

## 顶点着色器

顶点着色器的计算主要依赖于**顶点数量**和其本身**运算复杂度**，而运算复杂度一般来讲和**骨骼动画**、**Morph动画**以及**顶点照明**等等有关，所以一般来讲，我们有以下策略：

1. 控制模型顶点数量，这个一般是最有效的方法。
2. 如果有骨骼，控制骨骼数量。
3. 如果有Morph，控制差分数量。
4. 顶点照明灯光数量不宜过多。

>一些数据可以看后面的”可参考的数据“一章。

## 片段着色器

片段着色器的性能主要被**画布大小**和其本身的**运算复杂度**决定，对于目前主流的着色方法，一般而言片段着色器承载着更多的计算，比如**像素光照**、**Gamma矫正**、**HDR**等等，所以一般而言，其对运算复杂度更为敏感：

1. 控制画布分辨率是最有效的方法，但当然对于移动端应用一般这个我们不太好控制，所以适当对一些高清设备做降级是可以的。
2. 谨慎使用光照，可以用Lightmap来实现，详见[烘焙](../scene-editor/baking)。
3. 如果自己编写Shader，可以尝试使用较简单的光照算法。

>当然，随着设备的进步，在做好合理降级策略的情况下，我们可以期待PBR照明在移动端的大放异彩。

## 透明物体

透明物体的绘制也是GPU性能中非常重要但很容易被优化的一个点，透明物体相对于非透明物体，许多优化策略都将失效！而且由于`Blend`，会导致比一般物体多出不少开销，所以我们一般来说要尽量减少透明物体的使用，不是必要情况下请慎重！

## DrawCall

而以上所有的预算，都有一个先决条件——物体确实被绘制了，绘制一个物体，这个操作被我们称为**DrawCall**，DC的数量也是我们衡量性能的一个重要指标。

一般而言，我们需要将DC控制在可以达成的最低范围，这就有如下优化策略：

1. 控制相机的视椎体，对于透视相机就是`fov`、`near`、`far`这些，这决定着多少范围内的物体可以被绘制。
2. 适当得做模型合批，当然这可能会增加一部分模型体积，看需求而动。
3. 还有很多其他的优化策略，但WebGL1.0暂时不可行，我们后面会跟进。

## 预先提交

以上是针对每一帧不可避免的开销做的优化，还有一类优化可以只做一次后、整个过程都受益。

我们知道模型资源、纹理资源在使用前都需要先提交到GPU，然后视情况在CPU端效果，而在很多场合下，我们并不需要动态提交这些物体，而是可以在一开始就把需要的全部提交，这一般发生在**Loading**阶段。之后我们可以使用`visible`或者`unlink`/`relink`来控制物体的显示和逻辑运算，来避免动态提交造成的卡顿。

在此过程中一般Program也会被预先编译，又省去一些开销。

>在1.4.48版本后，可以直接使用`SceneActor`的`preRender`方法来手动、或者在`resource.instantiate`的时候使用配置参数中的`preRender`属性来控制。

当然，这个也是有代价的，会造成用户视角的加载时间变长，所以开具体项目吧。
